#!/usr/bin/env python3
"""
TempleDB Nix Environment Generator
Generates buildFHSEnvironment expressions from database configurations
"""

import os
import sys
import sqlite3
import json
import hashlib
from pathlib import Path
from typing import Dict, List, Optional

DB_PATH = os.path.expanduser("~/.local/share/templedb/templedb.sqlite")
ENV_OUTPUT_DIR = os.path.expanduser("~/.local/share/templedb/nix-envs")


class NixEnvGenerator:
    """Generate Nix FHS environments from database"""

    def __init__(self, db_path: str = DB_PATH):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.conn.row_factory = sqlite3.Row

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close()

    def get_environment(self, project_slug: str, env_name: str) -> Optional[Dict]:
        """Get environment configuration from database"""
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT
                ne.id,
                ne.project_id,
                p.slug AS project_slug,
                p.name AS project_name,
                p.repo_url,
                ne.env_name,
                ne.description,
                ne.base_packages,
                ne.target_packages,
                ne.multi_packages,
                ne.profile,
                ne.runScript
            FROM nix_environments ne
            JOIN projects p ON ne.project_id = p.id
            WHERE p.slug = ? AND ne.env_name = ? AND ne.is_active = 1
        """, (project_slug, env_name))

        row = cursor.fetchone()
        if not row:
            return None

        env = dict(row)

        # Get environment variables
        cursor.execute("""
            SELECT var_name, var_value, description
            FROM nix_env_variables
            WHERE environment_id = ?
            ORDER BY var_name
        """, (env['id'],))
        env['variables'] = [dict(r) for r in cursor.fetchall()]

        return env

    def list_environments(self, project_slug: Optional[str] = None) -> List[Dict]:
        """List all environments, optionally filtered by project"""
        cursor = self.conn.cursor()

        if project_slug:
            cursor.execute("""
                SELECT * FROM nix_environments_view
                WHERE project_slug = ?
                ORDER BY env_name
            """, (project_slug,))
        else:
            cursor.execute("SELECT * FROM nix_environments_view ORDER BY project_slug, env_name")

        return [dict(r) for r in cursor.fetchall()]

    def generate_nix_expression(self, env: Dict) -> str:
        """Generate Nix buildFHSEnvironment expression (optimized)"""

        # Parse JSON package lists once
        base_packages = json.loads(env['base_packages']) if env['base_packages'] else []
        target_packages = json.loads(env['target_packages']) if env['target_packages'] else []
        multi_packages = json.loads(env['multi_packages']) if env['multi_packages'] else []

        # Combine target packages for simpler expression
        all_target_pkgs = base_packages + target_packages

        # Build package list string (optimized - single join)
        def format_package_list(packages: List[str]) -> str:
            if not packages:
                return "[ ]"
            # Single line for small lists (faster Nix parsing)
            if len(packages) <= 3:
                return "[ " + " ".join(packages) + " ]"
            # Multi-line for larger lists
            return "[\n    " + "\n    ".join(packages) + "\n  ]"

        # Build profile script (optimized)
        profile = env.get('profile', '').strip()
        if profile:
            profile_str = f"  profile = ''\n{profile}\n  '';"
        else:
            profile_str = ""

        # Generate optimized Nix expression
        # Use simpler format for faster Nix evaluation
        nix_expr = f'''# {env['env_name']} environment for {env['project_slug']}
# Generated by TempleDB

{{ pkgs ? import <nixpkgs> {{}} }}:

(pkgs.buildFHSUserEnv {{
  name = "{env['project_slug']}-{env['env_name']}";

  targetPkgs = pkgs: (with pkgs; {format_package_list(all_target_pkgs)});

  multiPkgs = pkgs: (with pkgs; {format_package_list(multi_packages)});

{profile_str}

  runScript = "{env.get('runScript', 'bash')}";

  extraOutputsToInstall = [ "dev" "out" ];
}}).env
'''

        return nix_expr

    def save_environment(self, env: Dict, output_dir: str = ENV_OUTPUT_DIR, force: bool = False) -> str:
        """Save environment to Nix file (with caching)"""
        os.makedirs(output_dir, exist_ok=True)

        filename = f"{env['project_slug']}-{env['env_name']}.nix"
        filepath = os.path.join(output_dir, filename)

        # Generate new expression
        nix_expr = self.generate_nix_expression(env)

        # Check if file exists and content is unchanged (skip write if cached)
        if not force and os.path.exists(filepath):
            try:
                with open(filepath, 'r') as f:
                    existing_content = f.read()
                if existing_content == nix_expr:
                    # Content unchanged, skip write
                    return filepath
            except IOError:
                pass  # Fall through to write

        # Write file
        with open(filepath, 'w') as f:
            f.write(nix_expr)

        # Make executable
        os.chmod(filepath, 0o755)

        return filepath

    def auto_detect_environment(self, project_slug: str) -> Optional[Dict]:
        """Auto-detect environment based on project files"""
        cursor = self.conn.cursor()

        # Get project ID
        cursor.execute("SELECT id FROM projects WHERE slug = ?", (project_slug,))
        row = cursor.fetchone()
        if not row:
            return None

        project_id = row[0]

        # Analyze file types
        cursor.execute("""
            SELECT
                type_name,
                COUNT(*) AS count
            FROM files_with_types_view
            WHERE project_id = ?
            GROUP BY type_name
            ORDER BY count DESC
        """, (project_id,))

        file_types = {row[0]: row[1] for row in cursor.fetchall()}

        # Build package list based on file types
        packages = set()

        # Language detection
        if 'python' in file_types or 'python_script' in file_types:
            packages.update(['python311', 'python311Packages.pip', 'python311Packages.virtualenv'])

        if 'javascript' in file_types or 'typescript' in file_types:
            packages.update(['nodejs_20', 'nodePackages.npm'])

        if 'rust' in file_types:
            packages.update(['rustc', 'cargo', 'rust-analyzer'])

        if 'go' in file_types:
            packages.update(['go', 'gopls'])

        if 'c' in file_types or 'cpp' in file_types:
            packages.update(['gcc', 'cmake', 'gnumake'])

        # Common tools
        packages.update(['git', 'curl', 'wget', 'jq'])

        # Database tools if SQL present
        if 'sql' in file_types:
            packages.add('sqlite')

        return {
            'project_id': project_id,
            'packages': sorted(list(packages)),
            'detected_types': file_types
        }


def main():
    """CLI for Nix environment generator"""
    import argparse

    parser = argparse.ArgumentParser(description='TempleDB Nix Environment Generator')
    parser.add_argument('command', choices=['list', 'generate', 'auto-detect'],
                       help='Command to execute')
    parser.add_argument('-p', '--project', help='Project slug')
    parser.add_argument('-e', '--env', default='dev', help='Environment name (default: dev)')
    parser.add_argument('-o', '--output', help='Output directory')

    args = parser.parse_args()

    with NixEnvGenerator() as gen:
        if args.command == 'list':
            envs = gen.list_environments(args.project)
            if not envs:
                print("No environments found")
                return

            print(f"{'Project':<20} {'Environment':<15} {'Packages':<10} {'Sessions':<10}")
            print("-" * 60)
            for env in envs:
                packages = json.loads(env['base_packages'])
                pkg_count = len(packages)
                print(f"{env['project_slug']:<20} {env['env_name']:<15} {pkg_count:<10} {env['session_count']:<10}")

        elif args.command == 'generate':
            if not args.project:
                print("Error: --project required for generate")
                sys.exit(1)

            env = gen.get_environment(args.project, args.env)
            if not env:
                print(f"Error: Environment '{args.env}' not found for project '{args.project}'")
                sys.exit(1)

            output_dir = args.output or ENV_OUTPUT_DIR
            filepath = gen.save_environment(env, output_dir)

            print(f"âœ“ Generated Nix environment: {filepath}")
            print(f"\nTo enter the environment:")
            print(f"  nix-shell {filepath}")
            print(f"\nOr use the helper script:")
            print(f"  ./enter_env.sh {args.project} {args.env}")

        elif args.command == 'auto-detect':
            if not args.project:
                print("Error: --project required for auto-detect")
                sys.exit(1)

            result = gen.auto_detect_environment(args.project)
            if not result:
                print(f"Error: Project '{args.project}' not found")
                sys.exit(1)

            print(f"Auto-detected environment for {args.project}:")
            print(f"\nDetected file types:")
            for ftype, count in result['detected_types'].items():
                print(f"  {ftype}: {count} files")

            print(f"\nRecommended packages ({len(result['packages'])}):")
            for pkg in result['packages']:
                print(f"  - {pkg}")

            print(f"\nTo create this environment:")
            print(f"""
sqlite3 ~/.local/share/templedb/templedb.sqlite <<EOF
INSERT INTO nix_environments (project_id, env_name, description, base_packages)
VALUES (
    {result['project_id']},
    'auto',
    'Auto-detected environment',
    '{json.dumps(result['packages'])}'
);
EOF
""")


if __name__ == '__main__':
    main()
